---
layout: main
---
<section id="main-content">

  <h3>How to Write a Seneca Plugin</h3>

<p>
When you use the Seneca framework, you write plugins all the
time. They're an easy way to organize your action patterns.
</p>

<p>
A Seneca plugin is just a function that gets passed an <i>options</i>
object, and has a Seneca instance as its <i>this</i> variable. You
then <a href="http://senecajs.org/api.html#long-m-add"><i>add</i></a> some action
patterns in the body of the function, and you're done. There is no
callback.
</p>

<p>
This article will show some plugin examples, with code, going from
basic to advanced. It will cover the plugin API, and the conventions
to use when writing them. You'll need to log the behaviour of your
plugins, and you'll need to know how to debug them, so that will be
discussed too.
</p>

<p>
There are many Seneca plugins published on
<a href="http://www.npmjs.org/search?q=seneca%20plugin">NPM</a>. Most of them
can be extended and modifed by overriding their actions. You'll also
need to know how to do this. 
</p>

<p>
Finally, plugins provide you with a way to organize your own code, and
to make use of the 
<a href="http://martinfowler.com/articles/microservices.html">micro-services</a>
approach to software architecture, so that will be discussed too.
</p>


<a name="wp-simple"><h4>A Simple Plugin</h4></a>

<p>
Let's write a plugin that defines one action. The action uses the
plugin <i>options</i> argument to build a result.
</p>

{% highlight js %}
var plugin = function( options ) {

  this.add( {foo:'bar'}, function( args, done ) {
    done( null, {color: options.color} )
  })

}
{% endhighlight %}

<p>
A plugin is just a function. You can see that there is no callback
passed into this function that defines the plugin. So, how does Seneca
know that the plugin has fully initialized? It's an important
questions, because the plugin might depend on establishing a database
connection before it can operate properly.
</p>

<p>
As with most things in Seneca, you define an action pattern to handle
initialization, and make sure it happens in the proper order. We'll
talk about plugin initialization a little later. Many plugins don't
even need to initialize because all they do is define a set of action
patterns.
</p>

<p>
The example above defines a single action
pattern, <i>foo:bar</i>. This action provides a result based on the
options provided to the plugin. Plugin options are not required, but
if they are provided, they are passed in as the first argument to the
plugin definition function. The <i>options</i> argument is just a
JavaScript object with some properties. Seneca makes sure it always
exists. Even in the case where you have no options, you'll still get
an empty object.
</p>

<p>
The context object of the plugin function (that is, the value
of <i>this</i>), is a Seneca instance that you can use to define
actions. That means you don't need to
call <code>require('seneca')</code> when defining a plugin. This
Seneca instance provides the standard API, but the logging methods are
special - they append infomation about the plugin. So when you
call <code>this.log.debug('stuff about my plugin')</code>, the log
output will contain extra fields identifying the plugin, such as its
name. In this example, you haven't given the plugin a name (you'll see
how to do that in a moment), so Seneca will generate a short random
name for you.
</p>

<p>
You can use the plugin by calling
the <a href="http://senecajs.org/api.html#long-m-use">use</a> method
of the Seneca object. This loads the plugin into Seneca, after which
the action patterns defined by the plugin are available. You can then
call the <a href="http://senecajs.org/api.html#long-m-act">act</a>
method to trigger them, like so:
</p>

{% highlight js %}
// simple.js

var seneca = require('seneca')()

var plugin = function( options ) { ... } // as above

seneca.use( plugin, {color:'pink'} )
seneca.act( {foo:'bar'}, console.log )
{% endhighlight %}

<p>
This code is available in
the <a href="https://github.com/rjrodger/seneca/tree/master/doc/examples/write-a-plugin">doc/examples/write-a-plugin</a>
example, in the <i>simple.js</i> script. Running the script produces:
</p>

{% highlight bash %}
$ node simple.js
null { color: 'pink' }
{% endhighlight %}

<p>
In the output, the <i>null</i> is the first argument
to <i>console.log</i>, and indicates that there was no error.  The
output is a JavaScript object with single property <i>color</i>, the
value of which is set from the original options given to the plugin.
</p>


<h4>A Plugin is a Module</h4>

<p>
The Seneca <i>use</i> method can also accept module references. That
is, if you can <i>require</i> it, you can <i>use</i> it! Let's update the
simple example to show this. First, create a file called <i>foo.js</i>
containing the plugin code (all the files in this article are available on
the Seneca github
at <a href="https://github.com/rjrodger/seneca/tree/master/doc/examples/write-a-plugin">doc/examples/write-a-plugin</a>).
</p>

{% highlight js %}
// foo.js

module.exports = function( options ) {

  this.add( {foo:'bar'}, function( args, done ) {
    done( null, {color: options.color} )
  })

}
{% endhighlight %}

<p>
The <i>foo.js</i> file is a normal JavaScript file you can load into Node.js with <i>require</i>. It exposes a single function that takes the plugin <i>options</i>. To use the plugin, the code is almost the same as before, except that you pass in the <i>foo.js</i> relative file path in the same way you would for <i>require</i>.
</p>

{% highlight js %}
// module.js

var seneca = require('seneca')()

seneca.use( './foo.js', {color:'pink'} )
seneca.act( {foo:'bar'}, console.log )
{% endhighlight %}

<p>
The code produces the same output as before:
</p>

{% highlight bash %}
$ node module.js
null { color: 'pink' }
{% endhighlight %}

<p>
As well as local files and local modules, you can use public plugin modules
from <a href="https://www.npmjs.org/search?q=seneca">npmjs.org</a>. Let's use
the <a href="https://www.npmjs.org/package/seneca-echo">seneca-echo
plugin</a> as an example. This plugin echoes back arguments you send
to the <i>role:echo</i> pattern. First, <i>npm install</i> it:
</p>

{% highlight bash %}
$ npm install seneca-echo
{% endhighlight %}

<p>
Then use it:
</p>

{% highlight js %}
// echo.js

var seneca = require('seneca')()

seneca.use( 'seneca-echo' )
seneca.act( {role:'echo', foo:'bar'}, console.log )
{% endhighlight %}

<p>
Running <i>echo.js</i> produces:
</p>

{% highlight js %}
$ node echo.js
null { foo: 'bar' }
{% endhighlight %}

<p>
You aren't using any options in this example. The <i>seneca-echo</i>
plugin just reproduces the arguments passed in. In this
case <i>foo:bar</i>. The <i>role</i> property is not included in
the output.
</p>

<p>
The Seneca framework comes
with <a href="http://senecajs.org/plugins.html">many plugins</a>
written by the community. Feel free to write one yourself (after
reading this article!). By convention, public and generically useful
plugins are prefixed with <i>seneca-</i> as part of their name. This
lets you know the module is a Seneca plugin if you see it on
NPM. However, its a bit tedious to type in "seneca-" all the time, so
you are allowed to abbreviate plugin names by dropping the "seneca-"
prefix. That means you can use the the <i>seneca-echo</i> by just
providing the "echo" part of the name:
</p>

{% highlight js %}
seneca.use( 'echo' )
{% endhighlight %}



<h4>Give Your Plugin a Name</h4>

<p>
Your plugin needs a name. You can return a string from the plugin
definition function to give it one. When you look at the Seneca logs,
you can see what your plugin is doing. Let's try it!
</p>

{% highlight js %}
// name0.js

var plugin = function( options ) {

  this.add( {foo:'bar'}, function( args, done ) {
    done( null, {color: options.color} )
  })

  return 'name0'
}

var seneca = require('seneca')()

seneca.use( plugin, {color:'pink'} )
seneca.act( {foo:'bar'}, console.log )
{% endhighlight %}

<p>
And then run it like so:
</p>

{% highlight bash %}
$ node name0.js --seneca.log=plugin:name0
... DEBUG	act	name0	-	yvgt5y48wqjb	IN	{foo=bar}	bsot1xa3cr91	
... DEBUG	act	name0	-	yvgt5y48wqjb	OUT	{color=pink}	bsot1xa3cr91
null { color: 'pink' }
{% endhighlight %}

</p>
This uses Seneca's log filtering feature to focus on the log lines
that you care about. For more details on log filtering, read
the <a href="http://senecajs.org/logging-example.html">logging tutorial</a>.
</p>

<p>
To avoid repetition, the public plugins drop their "seneca-" prefix
when registering their names. Try this:
</p>

{% highlight bash %}
$ node echo.js --seneca.log=plugin:echo
... DEBUG	plugin	echo	-	add	echo	-	{role=echo}	jbnax2ssrr74
... DEBUG	act	echo	-	lkmlk29r6uwt	IN	{role=echo,foo=bar}	jbnax2ssrr74	
... DEBUG	act	echo	-	lkmlk29r6uwt	OUT	{foo=bar}	jbnax2ssrr74
null { foo: 'bar' }
{% endhighlight %}

<p>
You may have noticed something interesting. There were three lines of
logging output that time. Why didn't you see an "add" line for your
"name0" plugin? During the execution of its definition function, it
didn't have a name. You only gave it one when you returned a
name. Sometimes this is useful, because you can set a name
dynamically. Still, is it possible to set the name intially? Yes! Just
give the defining function a name:
</p>


{% highlight js %}
// name1.js

var plugin = function name1( options ) {

  this.add( {foo:'bar'}, function( args, done ) {
    done( null, {color: options.color} )
  })
}

var seneca = require('seneca')()

seneca.use( plugin, {color:'pink'} )
seneca.act( {foo:'bar'}, console.log )
{% endhighlight %}

<p>
Running this gives:
</p>

{% highlight bash %}
$ node name1.js --seneca.log=plugin:name1
... DEBUG	plugin	name1	-	add	name1	-	{foo=bar}	ikxdmc4xu9iz
... DEBUG	act	name1	-	b3uamicogfnm	IN	{foo=bar}	ikxdmc4xu9iz	
... DEBUG	act	name1	-	b3uamicogfnm	OUT	{color=pink}	ikxdmc4xu9iz
null { color: 'pink' }
{% endhighlight %}


<p>
When you load a plugin as a module then the module reference, as
supplied to the <i>use</i> method, becomes the initial name of the
module (Of course, you can override this by returning your own name)
Here's the <i>foo.js</i> plugin again:
</p>


{% highlight bash %}
$ node module.js --seneca.log=plugin:./foo.js
... DEBUG	plugin	./foo.js	-	add	./foo.js	-	{foo=bar}	hqv4y1w3p04j
... DEBUG	act	./foo.js	-	47ssblskuj59	IN	{foo=bar}	hqv4y1w3p04j	
... DEBUG	act	./foo.js	-	47ssblskuj59	OUT	{color=pink}	hqv4y1w3p04j
null { color: 'pink' }
{% endhighlight %}


<p>
There's an obvious risk that you might have a naming conflict. Seneca
allows this because it's more useful to have the ability to
override plugins. If you're defining your own set of plugin names,
it's best to choose a short prefix for your project. This is a good
idea in general for many frameworks!
</p>

<p>
For example, if you're working on the Manhattan project, choose the
prefix <i>mh</i>. Then call your "Trinity" plugin <i>mh-trinity</i>.
</p>

<p>
There are no hard and fast rules for naming your action
patterns. However, there are some conventions that help to organize
the patterns. Your plugin is providing functionality to the
system. This functionality fulfills a role in the system. So it makes
sense to use the form <i>role:plugin-name</i> as part of your action
pattern. This creates a pattern namespace to avoid clashes with other
plugin patterns. The use of the word "role" also indicates that other
plugins may override some aspects of this role (that is, aspects of
this functionality) by providing extensions to some of the action
patterns.
</p>

<p>
For example,
the <a href="https://github.com/rjrodger/seneca-vcache">seneca-vcache
plugin</a> overrides the standard entity patterns, of the
form <i>role:entity, cmd:*</i>. It does this to transparently add
caching to the database store operations.
</p>

<p>
Another common convention is to use the property "cmd" for the main
public commands exposed by the plugin. So, you might have, for
example:
</p>

{% highlight js %}
var plugin = function trinity( options ) {

  this.add( {role:'trinity', cmd:'detonate'}, function( args, done ) {
    // ... compress plutonium, etc
  })
}
{% endhighlight %}

<p>
Many of the public Seneca plugins on NPM follow this pattern. You may
find other patterns more useful in your own projects, so don't feel
obligated to follow this one.
</p>

<p>
If you load a plugin multiple times, only the last one loaded will be
used. You can however load multiple separate instances of the same
plugin, by using tag strings. NOTE: the action patterns will still be
overridden, unless the plugin handles this for you (like the example
below). The data store plugins, in particular, use this mechanism to
support multiple databases in the same system. For more details, read
the <a href="http://senecajs.org/data-entities.html">data entities
tutorial.</a>
</p>

<p>
Here's a simple example that uses tags. In this case,
the <i>bar.js</i> plugin defines an action pattern using one of its
option properties. This means that different action patterns are
defined depending on the options provided.
</p>

{% highlight js %}
// bar.js
module.exports = function( options ) {
  var tag = this.context.tag

  this.add( {foo:'bar', zed:options.zed}, function( args, done ) {
    done( null, {color: options.color, tag:tag} )
  })

}
{% endhighlight %}

<p>
You can access the tag value from the context property of the plugin
Seneca instance: <code>this.context.tag</code>
</p>

<p>
You still want to debug and track each instance of this plugin, so you
provide a tag each time you register it with the <i>use<i>
method. Tags can be supplied in two ways, either by description object
for the plugin, or by suffixing a <i>$</i> character, and then the
tag, to the plugin module reference. Here's the example code:
</p>

{% highlight js %}
// tags.js
var seneca = require('seneca')()

seneca.use( {name:'./bar.js',tag:'AAA'}, {zed:1,color:'red'} )
seneca.use( './bar.js$BBB',              {zed:2,color:'green'} )

seneca.act( {foo:'bar',zed:1}, console.log )
seneca.act( {foo:'bar',zed:2}, console.log )
{% endhighlight %}

<p>
Running this code produces the output:
</p>

{% highlight bash %}
$ node tags.js
null { color: 'red', tag: 'AAA' }
null { color: 'green', tag: 'BBB' }
{% endhighlight %}

<p>
Using the debug log shows the different instances of the plugin in action:
</p>

{% highlight bash %}
$ node tags.js --seneca.log=plugin:./bar.js
... DEBUG  plugin  ./bar.js  AAA  add  ./bar.js  AAA  {foo=bar,zed=1}  6vyoa1dlb1t9
... DEBUG  plugin  ./bar.js  BBB  add  ./bar.js  BBB  {foo=bar,zed=2}  gcigpuizai47
... DEBUG  act  ./bar.js  AAA  pamds7vlteyv  IN  {foo=bar,zed=1}  6vyoa1dlb1t9  
... DEBUG  act  ./bar.js  BBB  4uxz90gcczn5  IN  {foo=bar,zed=2}  gcigpuizai47  
... DEBUG  act  ./bar.js  AAA  pamds7vlteyv  OUT  {color=red,tag=AAA}  6vyoa1dlb1t9
null { color: 'red', tag: 'AAA' }
... DEBUG  act  ./bar.js  BBB  4uxz90gcczn5  OUT  {color=green,tag=BBB}  gcigpuizai47
null { color: 'green', tag: 'BBB' }
{% endhighlight %}

<p>
To isolate a tag, use these log settings:
</p>

{% highlight bash %}
$ node tags.js --seneca.log=plugin:./bar.js,tag:AAA
... DEBUG  plugin  ./bar.js  AAA  add  ./bar.js  AAA  {foo=bar,zed=1}  mp2cq990lzmy
... DEBUG  act  ./bar.js  AAA  9rp8luozaf92  IN  {foo=bar,zed=1}  mp2cq990lzmy  
... DEBUG  act  ./bar.js  AAA  9rp8luozaf92  OUT  {color=red,tag=AAA}  mp2cq990lzmy
null { color: 'red', tag: 'AAA' }
null { color: 'green', tag: 'BBB' }
{% endhighlight %}


<!--
<h4>Dealing with Options</h4>

- deepextend
- config files (basic)
- seneca.options


<h4>Dealing with Errors</h4>

- callback err
- seneca.fail/die
- exceptions



<h4>Using the Correct Context</h4>

- use this inside add funcs
- meta arguments - $ suffix; plugin metas
- state inside plugin

<h4>Initializing Your Plugin</h4>

- init action
- init order and logging, register etc
- gating, ready

<h4>Exporting Utility Objects</h4>
- export


<h4>Finding Your Plugin</h4>
- loading, use-plugin
- not found and other load errors

<h4>Finding Out About Plugins</h4>

- plugin api
- stats


<h4>Tips and Tricks for Writing Plugins</h4>

- var seneca = this
- dump patterns
- debug log
- failure to load



-->

<!--

The Seneca framework is defined by a philosophy that <a href="http://richardrodger.com">actions are better than objects</a>.
</p>

<p>
The only first-class citizens in the Seneca framework are <i>actions</i>. You register actions in Seneca by defining a set of key-value pairs that the action matches.
When a JSON document is submitted to Seneca, it triggers an action if a matching set of key-value pairs is found. The action returns another JSON document.
</p>

<p>
Actions can call other actions, and wrap existing actions. Groups of actions can work together to provide specific functionality, such as user management. Such groups are called <i>plugins</i>.
To keep things organized, a few conventions are used. A <i>role</i> property identifies a specific area of functionality. A <i>cmd</i> property identifies a specific action.
</p>

<p>
For example:
</p>

{% highlight js %}
seneca.act( {role:'entity', cmd:'save', ent:{...}}, 
            function(err,result) { ... } )
{% endhighlight %}

<p>
This action will save data entities to persistent storage, as part of the group of actions that perform the <i>role</i> of data persistence.
The <i>ent</i> property is an object containing the data of the data entity to save.

<p>
In Seneca, data persistence is provided by a set of actions. These are: 
<code>save</code>, <code>load</code>, <code>list</code>, <code>remove</code>. This provides a consistent interface for all other actions that need to persist data.
</p>

<p>
As convenience, these data entity actions are also available in the form of data entity objects, that expose the <i>cmd</i>s as methods - just like the ActiveRecord pattern. 
However, you cannot add business logic to these objects. <i><b>Business logic belongs inside actions</b></i>.
</p>


<h4>The Data Entity API</h4>

<p>
First you need a Seneca instance:
</p>

{% highlight js %}
var seneca = require('seneca')()
{% endhighlight %}

<p>
Then you can create data entity objects:
</p>

{% highlight js %}
var foo = seneca.make('foo')
{% endhighlight %}

<p>
The entity name is <i>foo</i>. If your underlying data store is
MongoDB, this data entity corresponds to the <i>foo</i>
collection. As a convenience, so you don't have to hook up a database, Seneca provides a transient in-memory store out of the
box (so you can just start coding!).
</p>

<p>
Next, add some data fields:
</p>

{% highlight js %}
foo.name = 'Apple'
foo.price = 1.99
{% endhighlight %}

<p>
The data fields are just ordinary JavaScript object properties.
</p>

<p>
Now, you need to save the data:
</p>

{% highlight js %}
foo.save$(function(err,foo) {
  console.log(foo)
})
{% endhighlight %}

<p>
The <code>save$</code> method invokes the <i>role:entity, cmd:save</i>
action, passing in the foo object as the value of <i>ent</i> argument.
</p>

<p>
The reason for the $ suffix is to namespace the <i>cmd</i>
methods. You can always be 100% certain that vanilla property names
"just work". Stick to alphanumeric characters and underscore and you'll be fine.
</p>

<p>
The <code>save$</code> method takes a callback, using the standard
Node.js idiom: The first parameter is an error object (if there was an
error), the second the result of the action. The <code>save$</code> method provides
a new copy of the foo entity. This copy has been saved to persistent
storage, and includes a unique <i>id</i> property.
</p>

<p>
Once you've saved the data entity, you'll want to load it again at
some point. Use the <code>load$</code> method to do this, passing in
the <i>id</i> property.
</p>


{% highlight js %}
var id = '...'
var foo_entity = seneca.make('foo')
foo_entity.load$( id, function(err,foo) {
  console.log(foo)
})
{% endhighlight %}

<p>
You can call the <code>load$</code> method on any data entity object
to load another entity of the same type. The original entity does
not change - you get the loaded entity back via the callback.
</p>
<p>
To delete entities, you also use the <i>id</i> property, with the 
<code>remove$</code> method:
</p>

{% highlight js %}
var id = '...'
var foo_entity = seneca.make('foo')
foo_entity.remove$( id, function(err) { ... })
{% endhighlight %}

<p>
To get a list of entities that match a query, use
the <code>list$</code> method:
</p>

{% highlight js %}
var foo_entity = seneca.make('foo')
foo_entity.list$( {price:1.99}, function(err,list) {
  list.forEach(function( foo ) {
    console.log(foo)
  })
})
{% endhighlight %}

<p>
The matching entities are returned as an array. The query is a set of
property values, all of which must match.  This is equivalent to a SQL
query of the form: <code> col1 = 'val1' AND col2 = 'val2' AND ... </code>. 
Seneca provides a common query format that works
across all data stores. The trade-off is that these queries have
limited expressiveness (more on this later, including the get-out-of-jail options).
</p>

<p>
One thing you can do is sort the results:
</p>

{% highlight js %}
foo_entity.list$( {price:1.99, sort$:{price:-1}}, function(err,list) {
  ...
})
{% endhighlight %}

<p>
The <code>sort$</code> meta argument takes a sub-object containing a single key, the field to sort. The value <code>+1</code> means sort ascending,
and the value <code>-1</code> means sort descending. The common query format only accepts a sort by one field.
</p>

<p>
You can also use queries with the <code>load$</code> and <code>remove$</code> methods. The first matching entity is selected.
</p>

<h4>Zone, Base and Name: The Entity Namespace</h4>

<p>
Your data can live in many different places. It can be persistent or transient. It may have business rules that apply to it.
It may be owned by different people.
</p>

<p>
Seneca lets you work with your data, without worrying about where it
lives, or what rules should apply to it. This makes it easy to handle
different types of data in different ways. To make this easier, Seneca provides a three layer namespace for data entities:
</p>

<ul>
<li><i>name</i>: the primary name of the entity. For example: <i>product</i></li>
<li><i>base</i>: group name for entities that "belong together". For example: <i>shop</i></li>
<li><i>zone</i>: name for a data set belonging to a business entity, geography, or customer. For example: <i>tenant001</i></li>
</ul>

<p>
The zone and base are optional. You can just use the name element in the same way you use ordinary database tables, and you'll be just fine.
Here's an example of creating a <i>foo</i> entity (as seen above):
</p>

{% highlight js %}
var foo_entity = seneca.make('foo')
{% endhighlight %}

<p>
Often, a set of plugins that provide the related functions, will use
the same <i>base</i>. This ensures that the entities used by these
plugins won't interfere with your own entities.
</p>

<p>
For example, the <a href="https://github.com/rjrodger/seneca-user">user</a> 
and <a href="https://github.com/rjrodger/seneca-auth">auth</a> plugins,
which handle user accounts, and login/logout, use the <i>sys</i> base,
and work with the following entities:
</p>

{% highlight js %}
var sys_user  = seneca.make('sys','user')
var sys_login = seneca.make('sys','login')
{% endhighlight %}

<p>
The underlying database needs to have a name for the table or
collection associated with an entity. The convention is to join the
base and name with an underscore, as <code>'_'</code> is accepted by most database
systems as a valid name character.  This means that <i>name</i>, <i>base</i> and
<i>zone</i> values should only be alphanumeric, and to be completely safe,
should never start with a number.
</p>

<p>
For the above plugins, the table or collection names would be:
<code>sys_user</code> and <code>sys_login</code>.
</p>

<p>
The <i>zone</i> element provides a higher level namespace that Seneca itself does not
use. It is merely a placeholder for your own needs.  For example, you
may need to isolate customer data into separate physical databases.
</p>

<p>
The zone is never part of the database table name. You use it by
registering multiple instances of the same database plugin, pointing
at different physical databases. Seneca's pattern matching makes this
automatic for you (see the entity type mapping examples below).
</p>

<p>
You can also use the zone for custom business rules. The zone, base and name appear as action arguments - just pattern match the underlying actions! (and there are examples below).
</p>

<h5>Creating an Entity with a Specific Zone, Base and Name</h5>

<p>
The <i>make</i> method is available on both the main Seneca object, and on each entity object (where it always has a $ suffix):
</p>

{% highlight js %}
// the alias make$ will also work
var foo = seneca.make('foo') 

// make() does not exist to avoid property clashes
var bar = foo.make$('bar') 
{% endhighlight %}

<p>
It optionally accepts up to three string arguments, specifying the zone, base and name, always in that order:
</p>

{% highlight js %}
var foo = seneca.make('foo') 
var bar_foo = seneca.make('bar','foo') 
var zen_bar_foo = seneca.make('zen','bar','foo') 
{% endhighlight %}

<p>
When no arguments are given, calling <code>make$</code> on an entity will create a new instance of the same kind (same zone, base and name):
</p>

{% highlight js %}
var foo = seneca.make('foo') 
var morefoo = foo.make$()
{% endhighlight %}

<p>
No data is copied, you get a completely new, empty, data entity (use <code>clone$</code> instead to copy the data).
If you pass in an object as the last argument to <code>make$</code>, it will be used to initialize the entity data fields:
</p>

{% highlight js %}
var foo = seneca.make('foo', {price:1.99,color:'red'}) 
console.log('price is '+foo.price+' and color is '+foo.color)
{% endhighlight %}


<p>
If you call the <code>toString</code> method on an entity, it will indicate the zone, base and name using the syntax <i>zone/base/name</i> as a prefix to the entity data:
</p>

{% highlight text %}
$zone/base/name:{id=...;prop=val,...}
{% endhighlight %}

<p>
If any of the namespace elements are not defined, a minus <code>'-'</code> is used as placeholder:
</p>

{% highlight text %}
$-/-/name:{id=...;prop=val,...}
{% endhighlight %}

<p>
The syntax <i>zone/base/name</i> is also used a shorthand for an
entity type pattern. For example, <i>-/bar/-</i> means any entities
that have base <i>bar</i>.
</p>

<h4>Using Databases to Store Entity Data</h4>

<p>
To store persistent data, you'll need to use an external
database. Each database needs a plugin that understands how to talk to
that database. The plugins normally use a specific driver module to do the actual talking.
</p>

<p>
For example, the <a href="https://github.com/rjrodger/seneca-mongo-store">seneca-mongo-driver</a> plugin
uses the <a href="http://mongodb.github.io/node-mongodb-native/">mongodb</a> module.
</p>

<p>
Using a data store plugin is easy. Register with Seneca and supply the database connection details as options to the plugin:
</p>

{% highlight js %}
var seneca = require('seneca')()
seneca.use('mongo-store',{
  name:'dbname',
  host:'127.0.0.1',
  port:27017
})
{% endhighlight %}

<p>
The database connection will need to be established before you can
save data. Use the <code>seneca.ready</code> function to supply a
callback that will be called once the database is good to go:
</p>

{% highlight js %}
seneca.ready(function(err) {
  var apple = seneca.make$('fruit')
  apple.name  = 'Pink Lady'
  apple.price = 1.99
  apple.save$(function(err,apple) {
    if( err ) return console.log(err);
    console.log( "apple = "+apple  )
  })
})
{% endhighlight %}

<p>
The <code>seneca.ready</code> function works for any plugin that has a callback dependency
like this - it will only be triggered once all the plugins are ready.
</p>

<p>
To close any open database connections, use the <code>seneca.close</code> method:
</p>

{% highlight js %}
seneca.close(function(err) {
  console.log('database closed!')
})
{% endhighlight %}


<h5>Data Store Plugins</h5>

<p>
To use a data store plugin, you'll normally need to install the module via npm:
</p>

{% highlight bash %}
npm install seneca-mongo-store
{% endhighlight %}

<p>
The data store plugins use a naming convention of the form seneca-<i>database</i>-store. The suffix <i>db</i> is dropped. Here are some of the existing data store plugins:
</p>

<ul> 
  </li><li>JSON files (on disk) - <a href="http://github.com/rjrodger/seneca-jsonfile-store">seneca-jsonfile-store</a>
  </li><li>MongoDB - <a href="http://github.com/rjrodger/seneca-mongo-store">seneca-mongo-store</a>
  </li><li>MySQL - <a href="https://github.com/mirceaalexandru/seneca-mysql-store">seneca-mysql-store</a>
  </li><li>PostgreSQL - <a href="https://github.com/marianr/seneca-postgres-store">seneca-postgres-store</a>
  </li><li>levelDB - <a href="https://github.com/rjrodger/seneca-level-store">seneca-level-store</a>
</li></ul>

<p>
Refer to their project pages for details on behaviour and configuration options. As a convenience, Seneca allows you to drop the <i>seneca-</i> prefix when registering the plugin:
</p>

{% highlight js %}
seneca.use('mongo-store',{ ... })
{% endhighlight %}

<p>
The default, built-in data store is <i>mem-store</i>, which provides a
transient in-memory store. This is very useful for quick prototyping
and allows you to get started quickly. By sticking to the common
entity feature set (see below), you can easily swap over to a real database at a
later point.
</p>

<p>
If you'd like to add support for a database to Seneca, 
here's the <a href="/data-store-guide.html">guide to writing data store plugins</a> 
</p>


<h5>Mapping Entities to Data Stores</h5>

<p>
One of the most useful features of the Seneca data entity model is the
ability to transparently use different databases. This is enabled by
the use of Seneca actions for all the underlying operations. This
makes it easy to pattern match against specific entity zones, bases
and names and send them to different data stores.
</p>

<p>
You can use the <i>map</i> option when registering a data store plugin
to specify the data entity types that it should support. All others will be ignored.
</p>

<p>
The map is a set of key-value pairs, where the key is an entity type
pattern, and the value a list of entity <i>cmd</i>s 
(such as <i>save</i>,<i>load</i>,<i>list</i>,<i>remove</i>,...), 
or <code>'*'</code>, which means the mapping applies to all <i>cmd</i>s.
</p>

<p>
The example mapping below means that all entities with the name <i>tmp</i>,
regardless of zone or base, will use the transient <i>mem-store</i>:
</p>

{% highlight js %}
seneca.use('mem-store',{ map:{ 
  '-/-/tmp':'*'
}})
{% endhighlight %}

<p>
To use different databases for different groups of data, use the <i>base</i> element:
</p>

{% highlight js %}
seneca.use('jsonfile-store',{ 
  folder:'json-data', map:{'-/json/-':'*'}
})

seneca.use('level-store',{ 
  folder:'level-data', map:{'-/level/-':'*'}
})
{% endhighlight %}

<p>
This mapping sends -/json/- entities to
the <a href="https://github.com/rjrodger/seneca-jsonfile-store">jsonfile</a>
data store, and -/level/- entities to
the <a href="https://github.com/rjrodger/seneca-level-store">leveldb</a>
data store.
</p>

<p>
Here it is in action:

{% highlight js %}
seneca.ready(function(err,seneca) {

  ;seneca
    .make$('json','foo',{propA:'val1',propB:'val2'})
    .save$(function(err,json_foo) {
      console.log(''+json_foo)

  ;seneca
    .make$('level','bar',{propA:'val3',propB:'val4'})
    .save$(function(err,level_bar) {
      console.log(''+level_bar)

  }) })
})
{% endhighlight %}

<p>
The full source code is available in the data-entities folder of the <a href="https://github.com/rjrodger/seneca-examples">seneca examples repository</a>.
(The ; prefix is just a marker to avoid excessive indentation)
</p>

<h4>Data Store Logging</h4>


<p>
You can track and debug the activity of data entities by reviewing the action log, and the plugin log for the datastore.
</p>

<p>
For example, run the example above, that uses both the jsonfile store and the leveldb store, using the <code>--seneca.log=type:act</code> log filter, and you get the output:
</p>

{% highlight bash %}
$ node main.js --seneca.log=type:act
...
2013-04-18T10:05:45.818Z  DEBUG  act  jsonfile-store  BCL  wa8xc5  In  {cmd=save,role=entity,ent=$-/json/foo:{id=;propA=val1;propB=val2},name=foo,base=json}  gx38qi
2013-04-18T10:05:45.821Z  DEBUG  act  jsonfile-store  BCL  wa8xc5  OUT  [$-/json/foo:{id=ulw8ew;propA=val1;propB=val2}]  gx38qi
...
2013-04-18T10:05:45.822Z  DEBUG  act  level-store  GPN  8dnjyt  IN  {cmd=save,role=entity,ent=$-/level/bar:{id=;propA=val3;propB=val4},name=bar,base=level}  8ml1p7
2013-04-18T10:05:45.826Z  DEBUG  act  level-store  GPN  8dnjyt  OUT  [$-/level/bar:{id=7de92fc0-f402-411d-80ea-59e435a8c398;propA=val3;propB=val4}]  8ml1p7
...
{% endhighlight %}

<p>
This shows the <i>role:entity, cmd:save</i> action of both data
stores. Seneca actions use a JSON-in/JSON-out model. You can trace
this using the <code>IN</code> and <code>OUT</code> markers in the log
entries. The <code>IN</code> and <code>OUT</code> entries are connected by an action identifer, such as <i>wa8xc5</i>. 
This lets you trace actions when they interleave asynchronously.
</p>

<p>
The <code>IN</code> log entries show the action arguments, including the entity data, and the entity zone, base and name (if defined). 
Once the action completes, the <code>OUT</code> log entries show the returned data. In particular, notice that the entities now have generated <i>id</i>s.
</p>

<p>
The data stores themselves also generate logging output. Try <code>--seneca.log=type:plugin</code> to see this:
</p>

{% highlight bash %}
$ node main.js --seneca.log=type:plugin
2013-04-18T10:39:54.961Z  DEBUG  plugin  jsonfile-store  QSG  cop6lx  save/insert  $-/json/foo:{id=nt7usm;propA=val1;propB=val2}  jsonfile-store~QSG~-/json/-
2013-04-18T10:40:19.802Z  DEBUG  plugin  level-store  JNG  save/insert  $-/level/bar:{id=7166037e-112d-448c-9afa-84e69d84aa25;propA=val3;propB=val4}  level-store~JNG~-/level/-
{% endhighlight %}

<p>
In this case, the data stores creates a log entry for each save operation that inserts data. The entity data is also shown.
Each plugin instance gets a three letter tag, such as <code>QSG</code>, or <code>JNG</code>. This helps you distinguish between multiple mappings that use the same data store.
Each data store plugin instance can be ths be described by the name of the data store plugin, the tag, and the associated mapping. This is the last element of the log entry. For example: 
<code>level-store~JNG~-/level/-</code>
</p>


<br /><br /><br />
<p>
That's all folks! Corrections and comments: please tweet <a href="https://twitter.com/nodeseneca">@nodeseneca</a>.
</p>

-->

        </section>

