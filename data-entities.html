---
layout: main
---
<section id="main-content">

  <h3>Seneca Data Entities</h3>

<p>
The Seneca framework provides a data entity API based loosely on the <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">ActiveRecord style</a>. Here's how it works.


<h4>The Seneca Philosophy</h4>

<p>
The Seneca framework is defined by a philosophy that <a href="http://richardrodger.com">actions are better than objects</a>.
</p>

<p>
The only first-class citizens in the Seneca framework are <i>actions</i>. You register actions in Seneca by defining a set of key-value pairs that the action matches.
When a JSON document is submitted to Seneca, it triggers an action if a matching set of key-value pairs is found. The action returns another JSON document.
</p>

<p>
Actions can call other actions, and wrap existing actions. Groups of actions can work together to provide specific functionality, such as user management. Such groups are called <i>plugins</i>.
To keep things organized, a few conventions are used. A <i>role</i> property identifies a specific area of functionality. A <i>cmd</i> property identifies a specific action.
</p>

<p>
For example:
</p>

{% highlight js %}
seneca.act( {role:'entity', cmd:'save', ent:{...}}, function(err,result){ ... })
{% endhighlight %}

<p>
This action will save data entities to persistent storage, as part of the group of actions that perform the <i>role</i> of data persistence.
The <i>ent</i> property is an object containing the data of the data entity to save.

<p>
In Seneca, data persistence is provided by a set of actions. These are: 
<code>save</code>, <code>load</code>, <code>list</code>, <code>remove</code>. This provides a consistent interface for all other actions that need to persist data.
</p>

<p>
As convenience, these data entity actions are also available in the form of data entity objects, that expose the <i>cmd</i>s as methods - just like the ActiveRecord pattern. 
However, you cannot add business logic to these objects. <i><b>Business logic belongs inside actions</b></i>.
</p>


<h4>The Data Entity API</h4>

<p>
First you need a Seneca instance:
</p>

{% highlight js %}
var seneca = require('seneca')()
{% endhighlight %}

<p>
Then you can create data entity objects:
</p>

{% highlight js %}
var foo = seneca.make('foo')
{% endhighlight %}

<p>
The entity name is <i>foo</i>. If your underlying data store is
MongoDB, this data entity corresponds to the <i>foo</i>
collection. Seneca provides a transient in-memory store out of the
box (so you can just start coding!).
</p>

<p>
Next, add some data fields:
</p>

{% highlight js %}
foo.name = 'Apple'
foo.price = 1.99
{% endhighlight %}

<p>
The data fields are just ordinary JavaScript object properties.
</p>

<p>
Now, you need to save the data:
</p>

{% highlight js %}
foo.save$(function(err,foo){
  console.log(foo)
})
{% endhighlight %}

<p>
The <code>save$</code> method invokes the <i>role:entity, cmd:save</i>
action, passing in the foo object as the value of <i>ent</i> argument.
</p>

<p>
The reason for the $ suffix is to namespace the <i>cmd</i>
methods. You can always be 100% certain that vanilla property names
"just work".
</p>

<p>
The <code>save$</code> method takes a callback, using the standard
Node.js idiom: The first parameter is an error object (if there was an
error), the second the result of the action. The <code>save$</code> method provides
a new copy of the foo entity. This copy has been saved to persistent
storage, and includes a unique <i>id</i> property.
</p>


Once you've saved the data entity, you'll want to load it again at
some point. Use the <code>load$</code> method to do this, passing in
the <i>id</i> property.

{% highlight js %}
var id = '...'
var foo_entity = seneca.make('foo')
foo_entity.load$( id, function(err,foo){
  console.log(foo)
})
{% endhighlight %}

You can call the <code>load$</code> method on any data entity object
to load a different entity of the same type. The original entity does
not change - you get the loaded entity back via the callback.

To delete entities, you also use the <i>id</i> property, with the 
<code>remove$</code> method:

{% highlight js %}
var id = '...'
var foo_entity = seneca.make('foo')
foo_entity.remove$( id, function(err){ ... })
{% endhighlight %}

To get a list of entities that match a query, use
the <code>list$</code> method:

{% highlight js %}
var foo_entity = seneca.make('foo')
foo_entity.list$( {price:1.99}, function(err,list){
  list.forEach(function( foo ){
    console.log(foo)
  })
})
{% endhighlight %}

The matching entities are returned as an array. The query is a set of
property values, all of which must match.  This is equivalent to a SQL
query of the form: <code> col1 = 'val1' AND col2 = 'val2' AND ... </code>. 
Seneca provides a common query format that works
across all data stores. The trade-off is that these queries have
limited expressiveness (more on this later, including the get-out-of-jail options).

One thing you can do is sort the results:

{% highlight js %}
foo_entity.list$( {price:1.99, sort$:{price:-1}}, function(err,list){
  ...
})
{% endhighlight %}

The <code>sort$</code> meta argument takes a sub-object containing a single key, the field to sort. The value <code>+1</code> means sort ascending,
and the value <code>-1</code> means sort descending. The common query format only accepts a sort by one field.

You can also use queries with the <code>load$</code> and <code>remove$</code> methods. The first matching entity is selected.


<h4>Zone, Base and Name: The Entity Namespace</h4>



<!--

- philosophy: objects v actions
- persistent data model - entities
- pragmatism: active record
  - api intro
  - simple example
- namespacing
- stores
- logging
- api coverage
  - standard data interface
- underlying actions
- native
- extending

-->


<p>
That's all folks! Corrections and comments: please tweet <a href="https://twitter.com/nodeseneca">@nodeseneca</a>.
</p>

        </section>

