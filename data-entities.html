---
layout: main
---
<section id="main-content">

  <h3>Seneca Data Entities</h3>

<p>
The Seneca framework provides a data entity API based loosely on the <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">ActiveRecord style</a>. Here's how it works.


<h4>The Seneca Philosophy</h4>

<p>
The Seneca framework is defined by a philosophy that <a href="http://richardrodger.com">actions are better than objects</a>.
</p>

<p>
The only first-class citizens in the Seneca framework are <i>actions</i>. You register actions in Seneca by defining a set of key-value pairs that the action matches.
When a JSON document is submitted to Seneca, it triggers an action if a matching set of key-value pairs is found. The action returns another JSON document.
</p>

<p>
Actions can call other actions, and wrap existing actions. Groups of actions can work together to provide specific functionality, such as user management. Such groups are called <i>plugins</i>.
To keep things organized, a few conventions are used. A <i>role</i> property identifies a specific area of functionality. A <i>cmd</i> property identifies a specific action.
</p>

<p>
For example:
</p>

{% highlight js %}
seneca.act( {role:'entity', cmd:'save', ent:{...}}, function(err,result){ ... })
{% endhighlight %}

<p>
This action will save data entities to persistent storage, as part of the group of actions that perform the <i>role</i> of data persistence.
The <i>ent</i> property is an object containing the data of the data entity to save.

<p>
In Seneca, data persistence is provided by a set of actions. These are: 
<code>save</code>, <code>load</code>, <code>list</code>, <code>remove</code>. This provides a consistent interface for all other actions that need to persist data.
</p>

<p>
As convenience, these data entity actions are also available in the form of data entity objects, that expose the <i>cmd</i>s as methods - just like the ActiveRecord pattern. 
However, you cannot add business logic to these objects. <i><b>Business logic belongs inside actions</b></i>.
</p>


<h4>The Data Entity API</h4>

<p>
First you need a Seneca instance:
</p>

{% highlight js %}
var seneca = require('seneca')()
{% endhighlight %}

<p>
Then you can create data entity objects:
</p>

{% highlight js %}
var foo = seneca.make('foo')
{% endhighlight %}

<p>
The entity name is <i>foo</i>. If your underlying data store is
MongoDB, this data entity corresponds to the <i>foo</i>
collection. Seneca provides a transient in-memory store out of the
box (so you can just start coding!).
</p>

<p>
Next, add some data fields:
</p>

{% highlight js %}
foo.name = 'Apple'
foo.price = 1.99
{% endhighlight %}

<p>
The data fields are just ordinary JavaScript object properties.
</p>

<p>
Now, you need to save the data:
</p>

{% highlight js %}
foo.save$(function(err,foo){
  console.log(foo)
})
{% endhighlight %}

<p>
The <code>save$</code> method invokes the <i>role:entity, cmd:save</i>
action, passing in the foo object as the value of <i>ent</i> argument.
</p>

<p>
The reason for the $ suffix is to namespace the <i>cmd</i>
methods. You can always be 100% certain that vanilla property names
"just work".
</p>

<p>
The <code>save$</code> methods takes a callback, using the standard
Node.js idiom: The first parameter is an error object (if there was an
error), the second the result of the action. The save$ method provides
a new copy of the foo entity. This copy has been saved to persistent
storage, and includes a unique <i>id</i> property.
</p>

<!--

loading
removing
listing and queries
common query syntax
-->






<!--

- philosophy: objects v actions
- persistent data model - entities
- pragmatism: active record
  - api intro
  - simple example
- namespacing
- stores
- api coverage
  - standard data interface
- underlying actions
- extending

-->


<p>
That's all folks! Corrections and comments: please tweet <a href="https://twitter.com/nodeseneca">@nodeseneca</a>.
</p>

        </section>

